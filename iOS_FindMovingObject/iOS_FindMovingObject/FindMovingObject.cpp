//
//  FindMovingObject.cpp
//  iOS_FindMovingObject
//
//  Created by albert on 2015/9/9.
//  Copyright (c) 2015å¹´ albert. All rights reserved.
//

#include "FindMovingObject.h"

// modify from bg_sub.cpp
//Background Subtraction
//#
//# @file bg_sub.cpp
//# @brief Background subtraction tutorial sample code
//# @author
//#

//opencv
#include "opencv2/core.hpp"
#include <opencv2/core/utility.hpp>
#include "opencv2/imgproc.hpp"
#include "opencv2/calib3d.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/videoio.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/video.hpp"

//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

// Global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method

Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int keyboard; //input from keyboard

string strImageToSave; //rd_add;
Mat CannyOutput;
Mat drawing;
vector<vector<Point> > contours;
vector<Vec4i> hierarchy;

int thresh = 50; // 50 ,100
int max_thresh = 255;
RNG rng(12345);

//erosion & dilation
Mat beforNR, AfterNR;
Mat erosion_dst, dilation_dst;
Mat threshold_output;

int erosion_elem = 0;
int erosion_size = 1;	 //rd_test;
int dilation_elem = 0;
int dilation_size = 1;	 //rd_test;

/** Function Headers */
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);
void Erosion(int, void*);
void Dilation(int, void*);
double dM01;
double dM10;
double dArea;
int posX=0;
int posY=0;
int iLastX = -1;
int iLastY = -1;
Scalar colorWhite;
Scalar colorRed;
Scalar colorBlue;


void my_calibration_init()
{
    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
}


//#
//# @function Erosion
//#
void Erosion(int, void*)
{
    int erosion_type = 0;
    if (erosion_elem == 0){ erosion_type = MORPH_RECT; }
    else if (erosion_elem == 1){ erosion_type = MORPH_CROSS; }
    else if (erosion_elem == 2) { erosion_type = MORPH_ELLIPSE; }
    
    Mat element = getStructuringElement(erosion_type,
                                        Size(2 * erosion_size + 1, 2 * erosion_size + 1),
                                        Point(erosion_size, erosion_size));
    /// Apply the erosion operation
    erode(beforNR, erosion_dst, element);
}

//#
//# @function Dilation
//#
void Dilation(int, void*)
{
    int dilation_type = 0;
    if (dilation_elem == 0){ dilation_type = MORPH_RECT; }
    else if (dilation_elem == 1){ dilation_type = MORPH_CROSS; }
    else if (dilation_elem == 2) { dilation_type = MORPH_ELLIPSE; }
    
    Mat element = getStructuringElement(dilation_type,
                                        Size(2 * dilation_size + 1, 2 * dilation_size + 1),
                                        Point(dilation_size, dilation_size));
    /// Apply the dilation operation
    //dilate(beforNR, dilation_dst, element);
    erode(erosion_dst, dilation_dst, element);
    //imshow("2step_Dilation", dilation_dst);
}

void processFrame(Mat& pViewIn, Mat& pViewOut) {
    
    //update the background model
    frame = pViewIn.clone();
    pMOG2->apply(frame, fgMaskMOG2);
    //get the frame number and write it on the current frame
    stringstream ss;
    rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
              cv::Scalar(255, 255, 255), -1);
    string frameNumberString = ss.str();
    putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
            FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
    
    beforNR = Mat::zeros(frame.size(), CV_8UC3);
    beforNR = fgMaskMOG2;
    
    Erosion(0, 0);
    Dilation(0, 0);
    
    AfterNR = dilation_dst;
    
    /// Detect edges using Threshold
    //threshold(AfterNR, threshold_output, thresh, 255, THRESH_BINARY);
    
    /// Detect edges using canny
    Canny(AfterNR, CannyOutput, 150, 255 * 3, 3);
    
    /// Find contours
    findContours(CannyOutput, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0));
    
    
    /// Approximate contours to polygons + get bounding rects and circles
    vector<vector<Point> > contours_poly(contours.size());
    vector<Rect> boundRect(contours.size());
    vector<Point2f>center(contours.size());
    vector<float>radius(contours.size());
    
    for (size_t i = 0; i < contours.size(); i++)
    {
        approxPolyDP(Mat(contours[i]), contours_poly[i], 3, true);
        boundRect[i] = boundingRect(Mat(contours_poly[i]));
        minEnclosingCircle(contours_poly[i], center[i], radius[i]);
    }
    
    /// Draw polygonal contour + bonding rects + circles
//    Mat drawing = Mat::zeros(CannyOutput.size(), CV_8UC3);
//    Mat masking = Mat::zeros(CannyOutput.size(), CV_8UC3);
//    Mat BlendImage = Mat::zeros(frame.size(), CV_8UC3);

    Mat drawing = Mat::zeros(CannyOutput.size(), CV_8UC4);
    Mat masking = Mat::zeros(CannyOutput.size(), CV_8UC4);
    Mat BlendImage = Mat::zeros(frame.size(), CV_8UC4);
    
    for (size_t i = 0; i< contours.size(); i++)
    {
        //Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
        
        //drawContours(drawing, contours_poly, (int)i, color, 1, 8, vector<Vec4i>(), 0, Point());
        rectangle(drawing, boundRect[i].tl(), boundRect[i].br(), colorRed, 2, 8, 0);
        //circle(drawing, center[i], (int)radius[i], color, 2, 8, 0);
        
        //drawContours(masking, contours_poly, (int)i, colorwhite, 1, 8, vector<Vec4i>(), 0, Point());
        rectangle(masking, boundRect[i].tl(), boundRect[i].br(), colorWhite, 2, 8, 0);
    }
    
    
    /// Get the moments
    vector<Moments> mu(contours.size());
    for (int i = 0; i < contours.size(); i++)
    {
        mu[i] = moments(contours[i], false);
        
        ///  Get the mass centers:
        dM01 = mu[i].m01;
        dM10 = mu[i].m10;
        dArea = mu[i].m00;
        
        vector<Point2f> mc(contours.size());
        for (int i = 0; i < contours.size(); i++)
        {
            mc[i] = Point2f(mu[i].m10 / mu[i].m00, mu[i].m01 / mu[i].m00);
            
            circle(drawing, mc[i], 4, colorBlue, -1, 8, 0);
            circle(masking, mc[i], 4, colorWhite, -1, 8, 0);
        }
    }

    BlendImage = frame - masking + drawing;
    //BlendImage = frame + drawing;
    pViewOut = BlendImage.clone();
    //show the current frame and the fg masks


}
